没看懂
public class Solution {
    Set < String > set = new HashSet <> ();
    public List < String > generatePalindromes(String s) {
        int[] map = new int[128];
        char[] st = new char[s.length() / 2];
        if (!canPermutePalindrome(s, map))
            return new ArrayList <> ();
        char ch = 0;
        int k = 0;
        for (int i = 0; i < map.length; i++) {
            if (map[i] % 2 == 1)
                ch = (char) i;
            for (int j = 0; j < map[i] / 2; j++) {
                st[k++] = (char) i;
            }
        }
        permute(st, 0, ch);
        return new ArrayList <String> (set);
    }
    public boolean canPermutePalindrome(String s, int[] map) {
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            map[s.charAt(i)]++;
            if (map[s.charAt(i)] % 2 == 0)
                count--;
            else
                count++;
        }
        return count <= 1;
    }
    public void swap(char[] s, int i, int j) {
        char temp = s[i];
        s[i] = s[j];
        s[j] = temp;
    }
    private void permute(char[] s, int l, char ch) {
        if (l == s.length) {
            set.add(new String(s) + (ch == 0 ? "" : ch) + new StringBuffer(new String(s)).reverse());
        } else {
            for (int i = l; i < s.length; i++) {
                if (s[l] != s[i] || l == i) {
                    swap(s, l, i);
                    permute(s, l + 1, ch);
                    swap(s, l, i);
                }
            }
        }
    }
}









my solution, LTE.. use permutation+isPalindrome
class Solution {
    public List<String> generatePalindromes(String s) {
        List<String> res = new ArrayList<>();
        if (s.isEmpty()) {
            res.add(s);
			return res;
		}
        
		boolean[] visited = new boolean[s.length()];
		helper(s, res, "", visited);
		return res;
    }
    private static void helper(String s, List<String> res, String answer, boolean[] visited) {
		if (answer.length() == s.length() && !res.contains(answer) && isPalindrome(answer)) {
			res.add(answer);
			return;
		}
		for (int i = 0; i < s.length(); i++) {
			if (!visited[i]) {
                if (i > 0 && s.charAt(i) == s.charAt(i-1) && visited[i-1]) {
                    return;
                }
                visited[i] = true;
                answer = answer + s.charAt(i);
                helper(s, res, answer, visited);
                visited[i] = false;
                answer = answer.substring(0, answer.length()-1);
			}
		}
	}
	private static boolean isPalindrome(String s) {
		if (s.isEmpty()) {
			return true;
		}
		int low = 0, high = s.length()-1;
		while (low < high) {
			if (s.charAt(low) != s.charAt(high)) {
				return false;
			}
			low++;
			high--;
		}
		return true;
	}
}
